devtools::check(".", document = TRUE, run_dont_test = TRUE, vignettes = FALSE, manual = TRUE)
# devtools::run_examples( start = "rm_sil")
# devtools::build_manual()
# devtools::install()
# check in R version 3.X.X
## run in terminal:
# /opt/R/3.6.3/bin/R
# devtools::check("~/Dropbox/R_package_testing/PhenotypeSpace/PhenotypeSpace", document = TRUE, run_dont_test = TRUE, vignettes = FALSE, manual = TRUE)
FUN <- "space_similarity"
#run function
source(file.path("./R", paste0(FUN,".R")))
# remove objects but no functions
rm(list = setdiff(ls(), c(lsf.str(), "FUN")))
# to troubleshoot internally
for(i in run.def.args(FUN)) try(eval(parse(text = i)), silent = T)
rm(i)
data("example_space")
# plot data
xs <- tapply(example_space$Dimension_1, example_space$ID, mean)
ys <- tapply(example_space$Dimension_2, example_space$ID, mean)
plot(example_space[, c("Dimension_1", "Dimension_2")], col = example_space$color, pch = 20, cex = 1.8)
text(xs, ys, labels = names(xs), cex = 2.5)
(so <- space_similarity(
X = example_space,
dimensions =  c("Dimension_1", "Dimension_2"),
group = "ID",
type = "mean.mcp.overlap"
))
X = example_space
dimensions =  c("Dimension_1", "Dimension_2")
group = "ID"
type = "mean.mcp.overlap"
# split in a list of vectors
X_l <- split(x = X, f = X[, group])
# stop if too small sample sizes
if (min(sapply(X_l, nrow)) < 2)
stop2("There is at least one group with less than 2 observations which is the minimum needed for overlap estimation")
# get densities
if (type %in% c("density.overlap", "mean.density.overlap")){
total_coors <-  spatstat.geom::as.ppp(as.matrix(X[, dimensions]), c(range(X[, dimensions[1]]), range(X[, dimensions[2]])))
total_space <-  raster::raster(spatstat.core::density.ppp(total_coors))
input_data <- lapply(X_l, function(Y, dims = dimensions){
coors <- spatstat.geom::as.ppp(as.matrix(Y[, dimensions]), c(range(Y[, dimensions[1]]), range(Y[, dimensions[2]])))
raster_dens <- raster::raster(spatstat.core::density.ppp(coors))
raster_dens <- raster::crop(raster::extend(raster_dens, total_space), total_space)
# convert to range 0-1
raster::values(raster_dens) <- (raster::values(raster_dens) - min(raster::values(raster_dens), na.rm = TRUE))
raster::values(raster_dens) <- raster::values(raster_dens)/ max(raster::values(raster_dens), na.rm = TRUE)
# keep 95% interval
raster::values(raster_dens)[raster::values(raster_dens) < 1 - outliers] <- NA
# same resolution and extend as total space
raster_dens <- raster::resample(raster_dens, total_space)
raster::extent(raster_dens)  <- c(0,1, 0, 1)
return(raster_dens)
})
names(input_data) <- names(X_l)
} else input_data <- X_l
# function to calculate areas
ovlp_fun <- function(W, Z, tp, dims, dist.meth) {
# get area
# raster density
if (tp %in% c("density.overlap", "mean.density.overlap")){
# convert NAs to 0
raster::values(W)[is.na(raster::values(W))] <- 0
raster::values(Z)[is.na(raster::values(Z))] <- 0
# 1 vs 2
wgt_ovlp.WvZ <- sum((raster::values(W) * raster::values(Z)) / raster::values(Z), na.rm = TRUE) / sum(raster::values(Z), na.rm = TRUE)
# 2 vs 1
wgt_ovlp.ZvW <- sum((raster::values(Z) * raster::values(W)) / raster::values(W), na.rm = TRUE) / sum(raster::values(W), na.rm = TRUE)
# convert to 1 if higher than 1
if (wgt_ovlp.WvZ > 1) wgt_ovlp.WvZ <- 1
if (wgt_ovlp.ZvW > 1) wgt_ovlp.ZvW <- 1
# put results in am matrix
out <- matrix(c(wgt_ovlp.WvZ, wgt_ovlp.ZvW), nrow = 1)
}
if (tp %in% c("mcp.overlap", "mean.mcp.overlap")){
sp::coordinates(W) <- stats::as.formula(paste("~", paste(dims, collapse = "+")))
sp::coordinates(Z) <- stats::as.formula(paste("~", paste(dims, collapse = "+")))
# get intersect
intrsct <- raster::intersect(adehabitatHR::mcp(W), adehabitatHR::mcp(Z))
if (!is.null(intrsct))
{
intrsctspace_size <- raster::area(intrsct)
ovlp1in2 <- intrsctspace_size / raster::area(adehabitatHR::mcp(W))
ovlp2in1 <- intrsctspace_size / raster::area(adehabitatHR::mcp(Z))
}      else ovlp1in2 <- ovlp2in1 <- 0
out <- matrix(c(ovlp2in1, ovlp1in2), nrow = 1)
}
if (tp == "proportional.overlap") {
sp::coordinates(W) <- stats::as.formula(paste("~", paste(dims, collapse = "+")))
sp::coordinates(Z) <- stats::as.formula(paste("~", paste(dims, collapse = "+")))
# both combined
Y <- rbind(W, Z)
# get intersect
intrsct <- raster::intersect(adehabitatHR::mcp(W, percent = outliers * 100), adehabitatHR::mcp(Z, percent = outliers * 100))
if (!is.null(intrsct))
{
intrsctspace_size <- raster::area(intrsct)
totalspace_size <- raster::area(adehabitatHR::mcp(Y, percent = outliers * 100))
ovlp1in2 <- ovlp2in1 <- intrsctspace_size / totalspace_size
}      else ovlp1in2 <- ovlp2in1 <- 0
out <- matrix(c(ovlp2in1, ovlp1in2), nrow = 1)
}
# distance among points
if (tp == "distance"){
U <- rbind(W, Z)
dists <- as.matrix(proxy::dist(U[ , dims], method = dist.meth,  convert_similarities = TRUE))
dists <- dists[U[, group] == W[, group][1], U[, group] == Z[, group][1]]
out <- matrix(mean(dists), nrow = 1)
}
if (tp == "centroid.distance") {
# both combined
Y <- rbind(as.data.frame(W), as.data.frame(Z))
frmla <- stats::as.formula(paste("cbind(", paste(dims, collapse = ","), ") ~ ", group))
centroid.dist <- proxy::dist(stats::aggregate(formula = frmla, data = Y, FUN = mean)[, -1], method = dist.meth,  convert_similarities = TRUE)
out <- matrix(centroid.dist, nrow = 1)
}
return(out)
}
# get all combinations to get pairwise overlaps
group_combs <- t(utils::combn(sort(unique(X[, group])), 2))
# calculate all similarities
similarities_l <- pblapply_phtpspc_int(1:nrow(group_combs), pbar = pb,  cl = parallel, function(i, data = input_data, gc = group_combs, dims = dimensions, typ = type, pair.scale = pairwise.scale, dist.meth = distance.method) {
if (type %in% c("density.overlap", "mean.density.overlap")){
W <- data[[which(names(data) == gc[i, 1])]]
Z <- data[[which(names(data) == gc[i, 2])]]
}
if (type %in% c("distance", "mcp.overlap", "mean.mcp.overlap", "proportional.overlap", "centroid.distance")){
W <- X_l[[which(names(X_l) == gc[i, 1])]]
Z <- X_l[[which(names(X_l) == gc[i, 2])]]
# pairwise scale
if (pair.scale) {
nrow_W <- nrow(W)
# bind and scale
U <- rbind(W, Z)
U[, dimensions[1]] <- scale(U[, dimensions[1]])
U[, dimensions[2]] <- scale(U[, dimensions[2]])
# split back
W <- U[1:nrow_W, ]
Z <- U[(nrow_W + 1):nrow(U), ]
}
}
suppressWarnings(similarities <- ovlp_fun(W, Z, typ, dims, dist.meth))
# put in a data frame
out_df <- if (type %in% c("mean.density.overlap", "mean.mcp.overlap", "centroid.distance", "proportional.overlap", "distance"))
data.frame(group.1 = gc[i, 1], group.2 = gc[i, 2], similarity = mean(similarities)) else
data.frame(group.1 = gc[i, 1], group.2 = gc[i, 2], similarity.1in2 = similarities[2], similarity.2in1 = similarities[1])
return(out_df)
})
parallel = 1
pb = TRUE
outliers = 0.95
pairwise.scale = FALSE
distance.method = "Euclidean"
ovlp_fun <- function(W, Z, tp, dims, dist.meth) {
# get area
# raster density
if (tp %in% c("density.overlap", "mean.density.overlap")){
# convert NAs to 0
raster::values(W)[is.na(raster::values(W))] <- 0
raster::values(Z)[is.na(raster::values(Z))] <- 0
# 1 vs 2
wgt_ovlp.WvZ <- sum((raster::values(W) * raster::values(Z)) / raster::values(Z), na.rm = TRUE) / sum(raster::values(Z), na.rm = TRUE)
# 2 vs 1
wgt_ovlp.ZvW <- sum((raster::values(Z) * raster::values(W)) / raster::values(W), na.rm = TRUE) / sum(raster::values(W), na.rm = TRUE)
# convert to 1 if higher than 1
if (wgt_ovlp.WvZ > 1) wgt_ovlp.WvZ <- 1
if (wgt_ovlp.ZvW > 1) wgt_ovlp.ZvW <- 1
# put results in am matrix
out <- matrix(c(wgt_ovlp.WvZ, wgt_ovlp.ZvW), nrow = 1)
}
if (tp %in% c("mcp.overlap", "mean.mcp.overlap")){
sp::coordinates(W) <- stats::as.formula(paste("~", paste(dims, collapse = "+")))
sp::coordinates(Z) <- stats::as.formula(paste("~", paste(dims, collapse = "+")))
# get intersect
intrsct <- raster::intersect(adehabitatHR::mcp(W), adehabitatHR::mcp(Z))
if (!is.null(intrsct))
{
intrsctspace_size <- raster::area(intrsct)
ovlp1in2 <- intrsctspace_size / raster::area(adehabitatHR::mcp(W))
ovlp2in1 <- intrsctspace_size / raster::area(adehabitatHR::mcp(Z))
}      else ovlp1in2 <- ovlp2in1 <- 0
out <- matrix(c(ovlp2in1, ovlp1in2), nrow = 1)
}
if (tp == "proportional.overlap") {
sp::coordinates(W) <- stats::as.formula(paste("~", paste(dims, collapse = "+")))
sp::coordinates(Z) <- stats::as.formula(paste("~", paste(dims, collapse = "+")))
# both combined
Y <- rbind(W, Z)
# get intersect
intrsct <- raster::intersect(adehabitatHR::mcp(W, percent = outliers * 100), adehabitatHR::mcp(Z, percent = outliers * 100))
if (!is.null(intrsct))
{
intrsctspace_size <- raster::area(intrsct)
totalspace_size <- raster::area(adehabitatHR::mcp(Y, percent = outliers * 100))
ovlp1in2 <- ovlp2in1 <- intrsctspace_size / totalspace_size
}      else ovlp1in2 <- ovlp2in1 <- 0
out <- matrix(c(ovlp2in1, ovlp1in2), nrow = 1)
}
# distance among points
if (tp == "distance"){
U <- rbind(W, Z)
dists <- as.matrix(proxy::dist(U[ , dims], method = dist.meth,  convert_similarities = TRUE))
dists <- dists[U[, group] == W[, group][1], U[, group] == Z[, group][1]]
out <- matrix(mean(dists), nrow = 1)
}
if (tp == "centroid.distance") {
# both combined
Y <- rbind(as.data.frame(W), as.data.frame(Z))
frmla <- stats::as.formula(paste("cbind(", paste(dims, collapse = ","), ") ~ ", group))
centroid.dist <- proxy::dist(stats::aggregate(formula = frmla, data = Y, FUN = mean)[, -1], method = dist.meth,  convert_similarities = TRUE)
out <- matrix(centroid.dist, nrow = 1)
}
return(out)
}
# get all combinations to get pairwise overlaps
group_combs <- t(utils::combn(sort(unique(X[, group])), 2))
i = 1
data = input_data
gc = group_combs
dims = dimensions
typ = type
pair.scale = pairwise.scale
dist.meth = distance.method
if (type %in% c("density.overlap", "mean.density.overlap")){
W <- data[[which(names(data) == gc[i, 1])]]
Z <- data[[which(names(data) == gc[i, 2])]]
}
if (type %in% c("distance", "mcp.overlap", "mean.mcp.overlap", "proportional.overlap", "centroid.distance")){
W <- X_l[[which(names(X_l) == gc[i, 1])]]
Z <- X_l[[which(names(X_l) == gc[i, 2])]]
# pairwise scale
if (pair.scale) {
nrow_W <- nrow(W)
# bind and scale
U <- rbind(W, Z)
U[, dimensions[1]] <- scale(U[, dimensions[1]])
U[, dimensions[2]] <- scale(U[, dimensions[2]])
# split back
W <- U[1:nrow_W, ]
Z <- U[(nrow_W + 1):nrow(U), ]
}
}
suppressWarnings(similarities <- ovlp_fun(W, Z, typ, dims, dist.meth))
tp %in% c("density.overlap", "mean.density.overlap")
tp = typ
tp %in% c("density.overlap", "mean.density.overlap")
# convert NAs to 0
raster::values(W)[is.na(raster::values(W))] <- 0
W
values(W)
raster::values(W)
W
raster(W)
is.na(raster::values(W))
# 1 vs 2
wgt_ovlp.WvZ <- sum((raster::values(W) * raster::values(Z)) / raster::values(Z), na.rm = TRUE) / sum(raster::values(Z), na.rm = TRUE)
# 2 vs 1
wgt_ovlp.ZvW <- sum((raster::values(Z) * raster::values(W)) / raster::values(W), na.rm = TRUE) / sum(raster::values(W), na.rm = TRUE)
# convert to 1 if higher than 1
if (wgt_ovlp.WvZ > 1) wgt_ovlp.WvZ <- 1
if (wgt_ovlp.ZvW > 1) wgt_ovlp.ZvW <- 1
# put results in am matrix
out <- matrix(c(wgt_ovlp.WvZ, wgt_ovlp.ZvW), nrow = 1)
# get area
# raster density
if (tp %in% c("density.overlap", "mean.density.overlap")){
# convert NAs to 0
raster::values(W)[is.na(raster::values(W))] <- 0
raster::values(Z)[is.na(raster::values(Z))] <- 0
# 1 vs 2
wgt_ovlp.WvZ <- sum((raster::values(W) * raster::values(Z)) / raster::values(Z), na.rm = TRUE) / sum(raster::values(Z), na.rm = TRUE)
# 2 vs 1
wgt_ovlp.ZvW <- sum((raster::values(Z) * raster::values(W)) / raster::values(W), na.rm = TRUE) / sum(raster::values(W), na.rm = TRUE)
# convert to 1 if higher than 1
if (wgt_ovlp.WvZ > 1) wgt_ovlp.WvZ <- 1
if (wgt_ovlp.ZvW > 1) wgt_ovlp.ZvW <- 1
# put results in am matrix
out <- matrix(c(wgt_ovlp.WvZ, wgt_ovlp.ZvW), nrow = 1)
}
if (tp %in% c("mcp.overlap", "mean.mcp.overlap")){
sp::coordinates(W) <- stats::as.formula(paste("~", paste(dims, collapse = "+")))
sp::coordinates(Z) <- stats::as.formula(paste("~", paste(dims, collapse = "+")))
# get intersect
intrsct <- raster::intersect(adehabitatHR::mcp(W), adehabitatHR::mcp(Z))
if (!is.null(intrsct))
{
intrsctspace_size <- raster::area(intrsct)
ovlp1in2 <- intrsctspace_size / raster::area(adehabitatHR::mcp(W))
ovlp2in1 <- intrsctspace_size / raster::area(adehabitatHR::mcp(Z))
}      else ovlp1in2 <- ovlp2in1 <- 0
out <- matrix(c(ovlp2in1, ovlp1in2), nrow = 1)
}
as.raster(W)
class(W)
sp::coordinatevalues(W)
raster(W)
a <- raster(W)
a
data[[1]]
# convert to raster
W <- raster::raster(W)
Z <- raster::raster(Z)
source("~/Dropbox/R_package_testing/PhenotypeSpace/R/space_similarity.R")
(so <- space_similarity(
X = example_space,
dimensions =  c("Dimension_1", "Dimension_2"),
group = "ID",
type = "mean.mcp.overlap"
))
ovlp_fun(W, Z, typ, dims, dist.meth)
X_l
class(X_l[[1]])
class(data[[1]])
source("~/Dropbox/R_package_testing/PhenotypeSpace/R/space_similarity.R")
(so <- space_similarity(
X = example_space,
dimensions =  c("Dimension_1", "Dimension_2"),
group = "ID",
type = "mean.mcp.overlap"
))
(so <- space_similarity(
X = example_space,
dimensions =  c("Dimension_1", "Dimension_2"),
group = "ID",
type = "mean.density.overlap"
))
(so <- space_similarity(
X = example_space,
dimensions =  c("Dimension_1", "Dimension_2"),
group = "ID",
type = "mcp.overlap"
))
W <- X_l[[which(names(X_l) == gc[i, 1])]]
Z <- X_l[[which(names(X_l) == gc[i, 2])]]
W
Z
sp::coordinates(W) <- stats::as.formula(paste("~", paste(dims, collapse = "+")))
sp::coordinates(Z) <- stats::as.formula(paste("~", paste(dims, collapse = "+")))
# get intersect
intrsct <- raster::intersect(adehabitatHR::mcp(W), adehabitatHR::mcp(Z))
# get intersect
intrsct <- raster::intersect(adehabitatHR::mcp(W), adehabitatHR::mcp(Z))
adehabitatHR::mcp(W)
W
(so <- space_similarity(
X = example_space,
dimensions =  c("Dimension_1", "Dimension_2"),
group = "ID",
type = "mean.mcp.overlap"
))
(so <- space_similarity(
X = example_space[,1:3],
dimensions =  c("Dimension_1", "Dimension_2"),
group = "ID",
type = "mcp.overlap"
))
(so <- space_similarity(
X = example_space[,1:3],
dimensions =  c("Dimension_1", "Dimension_2"),
group = "ID",
type = "mcp.overlap"
))
example_space
# get intersect
intrsct <- raster::intersect(adehabitatHR::mcp(W), adehabitatHR::mcp(Z))
intrsct <- raster::intersect(adehabitatHR::mcp(W), adehabitatHR::mcp(Z))
adehabitatHR::mcp(W)
adehabitatHR::mcp(Z)
intrsct <- raster::intersect(adehabitatHR::mcp(W), adehabitatHR::mcp(Z))
adehabitatHR::mcp(W)
adehabitatHR::mcp(W)[[1]]
adehabitatHR::mcp(W)[1]
# get intersect
intrsct <- raster::intersect(adehabitatHR::mcp(W)[[1]], adehabitatHR::mcp(Z)[[1]])
intrsct
adehabitatHR::mcp(W)[[1]]
W
# get intersect
intrsct <- raster::intersect(adehabitatHR::mcp(W), adehabitatHR::mcp(Z))
adehabitatHR::mcp(W)
adehabitatHR::mcp(Z)
raster::intersect(adehabitatHR::mcp(W), adehabitatHR::mcp(Z))
adehabitatHR::mcp(W)
plot(adehabitatHR::mcp(W))
plot(adehabitatHR::mcp(Z), add = TRUE)
intrsct <- raster::intersect((W), (Z))
intrsct
plot(intrsct, add = TRUE)
(adehabitatHR::mcp(W)
adehabitatHR::mcp(W)
adehabitatHR::mcp(W)
intrsctspace_size <- raster::area(intrsct)
intrsct
raster::area(intrsct)
intrsct
intrsct[[1]]
intrsct[1]
intrsct[1][[1]]
intrsct[1][1]
gOverlap <- function(hr1, hr2, ...) {
a <- gIntersection(hr1, hr2, ...)
if (is.null(a)) {
return(0)
}
gArea(a, byid=TRUE) / gArea(hr1, byid=TRUE)
}
gOverlap(W, Z)
library(rgeos)
gOverlap(W, Z)
gOverlap(W, W)
gOverlap(adehabitatHR::mcp(W), adehabitatHR::mcp(Z))
gOverlap(adehabitatHR::mcp(W), adehabitatHR::mcp(W))
# get intersect
intrsct <- rgeos::gIntersection(adehabitatHR::mcp(W), adehabitatHR::mcp(Z))
intrsct
source("~/Dropbox/R_package_testing/PhenotypeSpace/R/space_similarity.R")
(so <- space_similarity(
X = example_space[,1:3],
dimensions =  c("Dimension_1", "Dimension_2"),
group = "ID",
type = "mcp.overlap"
))
# plot data
xs <- tapply(example_space$Dimension_1, example_space$ID, mean)
ys <- tapply(example_space$Dimension_2, example_space$ID, mean)
plot(example_space[, c("Dimension_1", "Dimension_2")], col = example_space$color, pch = 20, cex = 1.8)
text(xs, ys, labels = names(xs), cex = 2.5)
(so <- space_similarity(
X = example_space[,1:3],
dimensions =  c("Dimension_1", "Dimension_2"),
group = "ID",
type = "mcp.overlap"
))
# system("autoconf  ")
# usethis::use_rcpp()
# setwd("./PhenotypeSpace/")
#delete NAMESPACE file
# Rcpp::compileAttributes()
#run document twice
# devtools::document(".")
# devtools::load_all()
#check with devtools
devtools::check(".", document = TRUE, run_dont_test = TRUE, vignettes = FALSE, manual = TRUE)
# devtools::run_examples( start = "rm_sil")
# devtools::build_manual()
# devtools::install()
# check in R version 3.X.X
## run in terminal:
# /opt/R/3.6.3/bin/R
# devtools::check("~/Dropbox/R_package_testing/PhenotypeSpace/PhenotypeSpace", document = TRUE, run_dont_test = TRUE, vignettes = FALSE, manual = TRUE)
FUN <- "space_similarity"
#run function
source(file.path("./R", paste0(FUN,".R")))
# remove objects but no functions
rm(list = setdiff(ls(), c(lsf.str(), "FUN")))
# to troubleshoot internally
for(i in run.def.args(FUN)) try(eval(parse(text = i)), silent = T)
rm(i)
data("example_space")
# plot data
xs <- tapply(example_space$Dimension_1, example_space$ID, mean)
ys <- tapply(example_space$Dimension_2, example_space$ID, mean)
plot(example_space[, c("Dimension_1", "Dimension_2")], col = example_space$color, pch = 20, cex = 1.8)
text(xs, ys, labels = names(xs), cex = 2.5)
(so <- space_similarity(
X = example_space[,1:3],
dimensions =  c("Dimension_1", "Dimension_2"),
group = "ID",
type = "mcp.overlap"
))
rectangular_to_triangular(so)
(so <- space_similarity(
X = example_space,
dimensions =  c("Dimension_1", "Dimension_2"),
group = "ID",
type = "mcp.overlap",
outliers = 0.99
))
rectangular_to_triangular(so, symmetric = FALSE)
# porportional
space_similarity(
X = example_space,
dimensions =  c("Dimension_1", "Dimension_2"),
group = "ID",
type = "proportional.overlap"
)
source("~/Dropbox/R_package_testing/PhenotypeSpace/R/space_similarity.R")
# porportional
space_similarity(
X = example_space,
dimensions =  c("Dimension_1", "Dimension_2"),
group = "ID",
type = "proportional.overlap"
)
# system("autoconf  ")
# usethis::use_rcpp()
# setwd("./PhenotypeSpace/")
#delete NAMESPACE file
# Rcpp::compileAttributes()
#run document twice
# devtools::document(".")
# devtools::load_all()
#check with devtools
devtools::check(".", document = TRUE, run_dont_test = TRUE, vignettes = FALSE, manual = TRUE)
# devtools::run_examples( start = "rm_sil")
# devtools::build_manual()
# devtools::install()
# check in R version 3.X.X
## run in terminal:
# /opt/R/3.6.3/bin/R
# devtools::check("~/Dropbox/R_package_testing/PhenotypeSpace/PhenotypeSpace", document = TRUE, run_dont_test = TRUE, vignettes = FALSE, manual = TRUE)
